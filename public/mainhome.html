<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>WeBooth - Ready to Snap</title>

    <script src="https://cdn.tailwindcss.com"></script>
    <link rel="preconnect" href="https://fonts.googleapis.com">
    <link rel="preconnect" href="https://fonts.gstatic.com" crossorigin>
    <link href="https://fonts.googleapis.com/css2?family=Inter:wght@400;500;700;800&family=Fredoka+One&display=swap" rel="stylesheet">

    <link rel="stylesheet" href="styles.css">

    <style>
/*
 * This file contains the custom CSS from the original <style> block.
 * Tailwind CSS utilities (like flex, p-4, md:p-8, etc.) remain in the HTML.
 */

body {
    background: radial-gradient(circle, #d4e893 40%, #feefff 60%);
    font-family: 'Inter', 'DM Sans', sans-serif, 'Fredoka One', cursive;
    min-height: 100vh;
}

.font-fredoka {
    font-family: 'Fredoka One', cursive;
}

.text-brand-pink {
    color: #c32d6c;
}

.topbar {
    display: flex;
    align-items: center;
    justify-content: space-between;
    margin-bottom: 1.5rem;
}

.topbar h1 {
    font-family: 'Fredoka One', cursive;
    font-size: 40px;
    font-weight: 900;
    color: #d23481;
    margin: 0;
    letter-spacing: -1px;
}

.right-buttons {
    display: flex;
    align-items: center;
    gap: 1rem;
}

.right-buttons button {
    display: flex;
    align-items: center;
    gap: 0.5rem;
    font-weight: 600;
    font-size: 1rem;
    border-radius: 12px;
    padding: 0.5rem 1rem;
    cursor: pointer;
    border: 2px solid #d23481;
    background-color: #fff;
    color: #d23481;
    transition: background-color 0.3s, color 0.3s;
}

.right-buttons button img {
    width: 28px;
    height: 28px;
}

.right-buttons button:hover,
.admin-btn {
    background-color: #d23481;
    color: #fff;
    border: 2px solid #d23481;
}


/* Card Container Styles (Camera, Layout, Effects) */
.card {
    background-color: #f4efe6; 
    border-radius: 1.5rem;
    padding: 1.5rem;
    box-shadow: 0 4px 10px rgba(221, 61, 147, 0.15); 
    backdrop-filter: blur(5px);
    border: 1px solid #f9d7e2; 
    /* The main card styles, position: relative is key for stacking context */
    position: relative; 
}

/* New style for the transparent camera preview card */
.transparent-card {
    background-color: transparent; /* Makes the card transparent */
    box-shadow: none; /* Removes the shadow */
    border: none; /* Removes the border */
    backdrop-filter: none; /* Removes the blur */
}

/* Settings Control Buttons (Camera, Layout inputs) */
.control-button {
    display: flex;
    align-items: center;
    width: 100%;
    /* Retaining the original background here for consistency */
    background-color: #f4efe6; 
    border: 1px solid #f9d7e2;
    border-radius: 0.75rem;
    padding: 0.75rem 1rem;
    font-weight: 500;
    text-align: left;
    transition: all 0.2s ease;
    position: relative;
    cursor: pointer; /* Added cursor for better UX on the button replacement */
}

.control-button:hover {
    background-color: #e8e3dc; /* Slight dark hover */
    border-color: #f9d7e2;
}

.control-button:active {
    transform: scale(0.98);
    background-color: #e8e3dc;
}

.control-button img {
    width: 1.5rem;
    height: 1.5rem;
    margin-right: 0.5rem;
}

/* Effect Selection Buttons */
.effect-button {
    background-color: #fff; /* Changed to pure white for better contrast inside the card */
    border: 1px solid #f9d7e2;
    border-radius: 0.5rem;
    padding: 0.75rem;
    font-weight: 500;
    text-align: center;
    transition: all 0.2s ease;
}

/* Effect Button Hover State (Inactive) */
.effect-button:hover:not(.active) {
    background-color: #fee2e2;
    border-color: #fca5a5;
    color: #ef4444;
    transform: translateY(-2px);
    box-shadow: 0 4px 6px -1px rgba(252, 165, 165, 0.3), 0 2px 4px -2px rgba(252, 165, 165, 0.2);
}

/* Effect Button Active State */
.effect-button.active {
    background-color: #ec4899;
    color: white;
    border-color: #ec4899;
}

.effect-button.active:hover {
    background-color: #db2777;
    border-color: #db2777;
    transform: translateY(-2px);
    box-shadow: 0 4px 6px -1px rgba(236, 72, 153, 0.4), 0 2px 4px -2px rgba(236, 72, 153, 0.2);
}

.effect-button:active:not(.active) {
    transform: scale(0.95);
    background-color: #fecaca;
    border-color: #ef4444;
    color: #ef4444;
}

.effect-button.active:active {
    transform: scale(0.95);
    background-color: #a21257;
    border-color: #a21257;
}

/* Fallback styling for missing icons */
.icon-fallback {
    width: 1.25rem;
    height: 1.25rem;
    background-color: #cbd5e1;
    color: #475569;
    border-radius: 50%;
    display: flex;
    align-items: center;
    justify-content: center;
    font-weight: bold;
    font-size: 0.75rem;
    margin-right: 0.5rem;
}

.control-button .icon-fallback {
    width: 1.5rem;
    height: 1.5rem;
    font-size: 0.875rem;
}

/* Camera Preview and CSS Filters */
#camera-preview {
    transition: filter 0.3s ease-in-out, transform 0.4s ease;
}

.preview-flipped {
    transform: scaleX(-1);
}

.filter-none { filter: none; }
.filter-bw { filter: grayscale(100%); }
.filter-warm { filter: sepia(70%); }
.filter-cool { filter: contrast(1.1) brightness(1.1) saturate(1.3) hue-rotate(-15deg); }
.filter-retro { filter: sepia(100%) brightness(0.9) contrast(1.1); }
.filter-noir { filter: grayscale(100%) contrast(1.2) brightness(0.8); }

/* Main Action Buttons (Start/Upload) */
.action-button {
    display: inline-flex;
    align-items: center;
    justify-content: center;
    padding: 0.75rem 2rem;
    border-radius: 9999px;
    font-size: 1.125rem;
    font-weight: 700;
    box-shadow: 0 4px 14px 0 rgba(0, 0, 0, 0.1);
    background: linear-gradient(90deg, #f645b1 0%, #f4b744 100%);
    color: white;
    cursor: pointer;
    margin-bottom: 15px;
    transition: background 0.3s ease;
    text-decoration: none;
    border: none;
}

.action-button:hover {
    background: linear-gradient(90deg, #f4b744 0%, #f645b1 100%);
}

.action-button:active {
    transform: scale(0.98);
    opacity: 0.9;
}

/* Consolidated utility class for select arrow icon */
.select-icon-arrow {
    position: absolute; 
    right: 1rem; 
    top: 50%; 
    transform: translateY(-50%); 
    width: 1.25rem; 
    height: 1.25rem; 
    color: #9ca3af; 
    pointer-events: none;
    z-index: 10;
}

/* --- CUSTOM DROPDOWN STYLES --- */
.custom-options-list {
    list-style: none;
    padding: 0;
    margin: 0;
    font-weight: 500;
    /* High z-index to ensure the list item is above everything else */
    z-index: 999; 
}

.custom-options-list li {
    padding: 0.75rem 1rem;
    transition: all 0.2s ease;
    text-align: left;
}

.custom-options-list li:hover {
    background-color: #fecaca;
    color: #d23481;
}

.option-active {
    font-weight: 700;
    color: #d23481; /* Highlight selected option */
    background-color: #fce7f3;
}

/* Container for all dropdowns to establish a stacking context for the list */
.dropdown-container {
    position: relative;
    width: 100%; 
    /* This z-index is lower than the list (z-999) but higher than default elements */
    z-index: 30; 
}

/* Custom class for Camera Card to ensure its dropdown (Timer) is on top of Layout card */
.camera-card {
    position: relative;
    z-index: 20; 
}
/* Custom class for Layout Card to ensure its dropdowns are on top of Effects card */
.layout-card {
    position: relative;
    z-index: 10; 
}
</style>

</head>
<body class="text-gray-800 min-h-screen flex flex-col">

    <div class="max-w-7xl mx-auto w-full flex-grow flex flex-col justify-center p-4 md:p-8">

        <header class="flex flex-col md:flex-row items-center justify-between gap-4 mb-8">
            <div class="flex items-center">
                <img src="Icons/11.svg" alt="WeBooth Logo"
                    class="w-12 h-12 md:w-16 md:h-16 mr-3"
                    onerror="this.outerHTML = '<div class=\'icon-fallback p-2 text-xl\'>W</div>'">

                <h1 class="text-2xl md:text-3xl text-brand-pink leading-tight font-fredoka">
                    WeBooth is Ready<br>to Snap
                </h1>
            </div>

            <header class="topbar">
        <div class="right-buttons">
          <button onclick="window.location.href='booth.html'">
            <img src="Icons/2.svg" alt="Booth icon" />
            Booth
          </button>
          <button onclick="window.location.href='finalprof.html'">
            <img src="Icons/4.svg" alt="Profile icon" />
            Profile
          </button>
        </div>
      </header>

        </header>

        <main class="grid grid-cols-1 lg:grid-cols-3 gap-8">

            <div class="lg:col-span-1 flex flex-col gap-6">

                <section class="card camera-card"> 
                    <h2 class="text-2xl font-bold mb-4">Camera</h2>
                    <div class="grid grid-cols-2 gap-4">

                        <button id="switch-camera-btn" class="control-button">
                            <img src="Icons/2.svg" alt="Switch Camera"
                                class="w-6 h-6 mr-2"
                                onerror="this.outerHTML = '<div class=\'icon-fallback\'>SC</div>'">
                            <span class="flex-1 whitespace-nowrap overflow-hidden text-ellipsis">
                                Mirror
                            </span>
                        </button>

                        <div class="dropdown-container">
                            <button id="custom-timer-toggle" class="control-button justify-between">
                                <div class="flex items-center">
                                    <img src="Icons/1.svg" alt="Timer"
                                        class="w-6 h-6 mr-2"
                                        onerror="this.outerHTML = '<div class=\'icon-fallback\'>T</div>'">
                                    <span id="selected-timer-text">Timer</span>
                                </div>
                                <svg xmlns="http://www.w3.org/2000/svg" class="w-5 h-5 text-gray-400 ml-2" fill="none" viewBox="0 0 20 20" stroke="currentColor">
                                    <path fill-rule="evenodd" d="M5.293 7.293a1 1 0 011.414 0L10 10.586l3.293-3.293a1 1 0 111.414 1.414l-4 4a1 1 0 01-1.414 0l-4-4a1 1 0 010-1.414z" clip-rule="evenodd" />
                                </svg>
                            </button>

                            <ul id="custom-timer-options" class="hidden absolute top-full left-0 mt-2 w-full bg-white border border-pink-200 rounded-xl shadow-xl custom-options-list">
                                <li class="p-3 cursor-pointer timer-option option-active" data-value="0" data-label="Timer">None</li>
                                <li class="p-3 cursor-pointer timer-option" data-value="3" data-label="3 Seconds">3 Seconds</li>
                                <li class="p-3 cursor-pointer timer-option" data-value="5" data-label="5 Seconds">5 Seconds</li>
                                <li class="p-3 cursor-pointer timer-option" data-value="10" data-label="10 Seconds">10 Seconds</li>
                            </ul>
                        </div>
                        </div>
                </section>

                <section class="card layout-card">
                    <h2 class="text-2xl font-bold mb-4">Layout</h2>
                    <div class="grid grid-cols-2 gap-4">

                        <div class="dropdown-container">
                            <button id="custom-frame-toggle" class="control-button justify-between">
                                <div class="flex items-center">
                                    <img src="Icons/6.svg" alt="Frame Size"
                                        class="w-6 h-6 mr-2"
                                        onerror="this.outerHTML = '<div class=\'icon-fallback\'>FS</div>'">
                                    <span id="selected-frame-text">Frame Size </span>
                                </div>
                                <svg xmlns="http://www.w3.org/2000/svg" class="w-5 h-5 text-gray-400 ml-2" fill="none" viewBox="0 0 20 20" stroke="currentColor">
                                    <path fill-rule="evenodd" d="M5.293 7.293a1 1 0 011.414 0L10 10.586l3.293-3.293a1 1 0 111.414 1.414l-4 4a1 1 0 01-1.414 0l-4-4a1 1 0 010-1.414z" clip-rule="evenodd" />
                                </svg>
                            </button>
                            <ul id="custom-frame-options" class="hidden absolute top-full left-0 mt-2 w-full bg-white border border-pink-200 rounded-xl shadow-xl custom-options-list">
                                <li class="p-3 cursor-pointer frame-option option-active" data-value="" data-label="Frame Size">Frame Size</li>
                                <li class="p-3 cursor-pointer frame-option" data-value="2 x 6" data-label="2 x 6 inches">2 x 6 inches</li>
                                <li class="p-3 cursor-pointer frame-option" data-value="4 x 6" data-label="4 x 6 inches">4 x 6 inches</li>
                            </ul>
                        </div>
                        <div class="dropdown-container">
                            <button id="custom-shots-toggle" class="control-button justify-between">
                                <div class="flex items-center">
                                    <img src="Icons/7.svg" alt="Shots"
                                        class="w-6 h-6 mr-2"
                                        onerror="this.outerHTML = '<div class=\'icon-fallback\'>S</div>'">
                                    <span id="selected-shots-text">Shots</span>
                                </div>
                                <svg xmlns="http://www.w3.org/2000/svg" class="w-5 h-5 text-gray-400 ml-2" fill="none" viewBox="0 0 20 20" stroke="currentColor">
                                    <path fill-rule="evenodd" d="M5.293 7.293a1 1 0 011.414 0L10 10.586l3.293-3.293a1 1 0 111.414 1.414l-4 4a1 1 0 01-1.414 0l-4-4a1 1 0 010-1.414z" clip-rule="evenodd" />
                                </svg>
                            </button>
                            <ul id="custom-shots-options" class="hidden absolute top-full left-0 mt-2 w-full bg-white border border-pink-200 rounded-xl shadow-xl custom-options-list">
                                <li class="p-3 cursor-pointer shots-option option-active" data-value="0" data-label="Shots">Shots</li>
                                <li class="p-3 cursor-pointer shots-option" data-value="1" data-label="1 Shot">1 Shot</li>
                                <li class="p-3 cursor-pointer shots-option" data-value="2" data-label="2 Shots">2 Shots</li>
                                <li class="p-3 cursor-pointer shots-option" data-value="3" data-label="3 Shots">3 Shots</li>
                                <li class="p-3 cursor-pointer shots-option" data-value="4" data-label="4 Shots">4 Shots</li>
                            </ul>
                        </div>
                        </div>
                </section>

                <section class="card">
                    <h2 class="text-2xl font-bold mb-4">Effects</h2>
                    <div class="grid grid-cols-3 gap-5">
                        <button class="effect-button active" data-filter="filter-none">None</button>
                        <button class="effect-button" data-filter="filter-bw">B&W</button>
                        <button class="effect-button" data-filter="filter-warm">Warm</button>
                        <button class="effect-button" data-filter="filter-cool">Cool</button>
                        <button class="effect-button" data-filter="filter-retro">Retro</button>
                        <button class="effect-button" data-filter="filter-noir">Noir</button>
                    </div>
                </section>
            </div>

<div class="lg:col-span-2">
    <section class="card transparent-card">
        <video id="camera-preview" class="w-full h-[500px] md:h-[425px] bg-gradient-to-b from-white-200 to-white-200 rounded-2xl border-4 border-white shadow-xl mb-6" autoplay muted playsinline>
            Your browser does not support the video tag.
        </video>

        <div class="flex items-center justify-center gap-6">
    <button id="start-btn" class="action-button">
        <svg xmlns="http://www.w3.org/2000/svg" class="w-6 h-6 mr-2" fill="none" viewBox="0 0 24 24" stroke="currentColor" stroke-width="2" stroke-linecap="round" stroke-linejoin="round">
            <path d="M3 9a2 2 0 012-2h.93a2 2 0 001.664-.89l.812-1.22A2 2 0 0110.07 4h3.86a2 2 0 011.664.89l.812 1.22A2 2 0 0018.07 7H19a2 2 0 012 2v9a2 2 0 01-2 2H5a2 2 0 01-2-2V9z" />
            <circle cx="12" cy="13" r="3" />
        </svg>
        START
    </button>
    <button id="upload-btn" type="button" class="action-button">
        <svg xmlns="http://www.w3.org/2000/svg" class="w-6 h-6 mr-2" fill="none" viewBox="0 0 24 24" stroke="currentColor" stroke-width="2">
            <path stroke-linecap="round" stroke-linejoin="round" d="M4 16v1a3 3 0 003 3h10a3 3 0 003-3v-1m-4-8l-4-4m0 0L8 8m4-4v12" />
        </svg>
        UPLOAD
    </button>
    <input type="file" id="file-input" accept="image/*" class="hidden">
</div>
    </section>
</div>

            </div>

        </main>
    </div>


<script>
document.addEventListener('DOMContentLoaded', () => {
    // -------------------------------------------
    // INITIAL SETUP & RETAKE CHECK
    // -------------------------------------------
    const urlParams = new URLSearchParams(window.location.search);
    const retakeIndex = urlParams.get('retake');
    let existingImages = [];
    
    // --- Custom Control Elements and State ---
    
    // Timer
    const customTimerToggle = document.getElementById('custom-timer-toggle');
    const customTimerOptions = document.getElementById('custom-timer-options');
    const selectedTimerText = document.getElementById('selected-timer-text');
    let selectedTimerValue = 0; 
    
    // Frame Size (New)
    const customFrameToggle = document.getElementById('custom-frame-toggle');
    const customFrameOptions = document.getElementById('custom-frame-options');
    const selectedFrameText = document.getElementById('selected-frame-text');
    let selectedFrameSize = ""; // e.g., "2 x 6"
    
    // Shots (New)
    const customShotsToggle = document.getElementById('custom-shots-toggle');
    const customShotsOptions = document.getElementById('custom-shots-options');
    const selectedShotsText = document.getElementById('selected-shots-text');
    let selectedNumShots = 0; // e.g., 4
    
    // The rest of the elements
    const cameraPreview = document.getElementById('camera-preview');
    const startButton = document.getElementById('start-btn');
    const uploadButton = document.getElementById('upload-btn');
    const fileInput = document.getElementById('file-input');
    
    // --- Utility Functions for Custom Dropdowns ---
    
    function setupDropdown(toggleBtn, optionsList, activeClass, setValueCallback) {
        // Toggle visibility
        toggleBtn.addEventListener('click', () => {
            // Close other open dropdowns
            [customTimerOptions, customFrameOptions, customShotsOptions].forEach(ul => {
                if (ul !== optionsList) ul.classList.add('hidden');
            });
            optionsList.classList.toggle('hidden');
        });

        // Handle option selection
        optionsList.addEventListener('click', (event) => {
            const option = event.target.closest(`.${activeClass}-option`);
            if (option) {
                optionsList.querySelectorAll(`.${activeClass}-option`).forEach(opt => opt.classList.remove('option-active'));
                
                option.classList.add('option-active');
                
                // Update global state and button text
                const value = option.dataset.value;
                const label = option.dataset.label || option.textContent;
                setValueCallback(value, label);
                
                optionsList.classList.add('hidden'); // Hide after selection
            }
        });
    }

    // Set up initial state (Frame Size and Shots)
    const initOption = (optionsList, activeClass, defaultValue, defaultLabel) => {
        const initialOpt = optionsList.querySelector(`[data-value="${defaultValue}"]`);
        if (initialOpt) {
            initialOpt.classList.add('option-active');
            // Ensure the initial button text is correct
            document.getElementById(`selected-${activeClass}-text`).textContent = defaultLabel;
        }
    };


    // --- Setup All Dropdowns ---

    // Timer Setup
    setupDropdown(customTimerToggle, customTimerOptions, 'timer', (value, label) => {
        selectedTimerValue = parseInt(value);
        selectedTimerText.textContent = label;
    });
    initOption(customTimerOptions, 'timer', selectedTimerValue, "Timer");

    // Frame Size Setup
    setupDropdown(customFrameToggle, customFrameOptions, 'frame', (value, label) => {
        selectedFrameSize = value;
        selectedFrameText.textContent = label;
    });
    initOption(customFrameOptions, 'frame', selectedFrameSize, "Frame Size");

    // Shots Setup
    setupDropdown(customShotsToggle, customShotsOptions, 'shots', (value, label) => {
        selectedNumShots = parseInt(value) || 0;
        selectedShotsText.textContent = label;
    });
    initOption(customShotsOptions, 'shots', selectedNumShots, "Shots");

    // Close dropdowns when clicking anywhere outside
    document.addEventListener('click', (event) => {
        if (!event.target.closest('.dropdown-container')) {
            [customTimerOptions, customFrameOptions, customShotsOptions].forEach(ul => {
                ul.classList.add('hidden');
            });
        }
    });

    // --- End Custom Dropdown Setup ---


    // If retake mode is active, load the existing array of images
    if (retakeIndex !== null) {
        try {
            const imagesJson = sessionStorage.getItem('capturedImagesArray');
            if (imagesJson) {
                existingImages = JSON.parse(imagesJson);
            }
        } catch (e) {
            console.error("Failed to load existing captured images for retake:", e);
        }
        
        // Update UI to reflect retake mode
        const retakeShotNumber = parseInt(retakeIndex) + 1;
        const mainTitle = document.querySelector('h1.font-fredoka');
        if (mainTitle) {
            mainTitle.innerHTML = `Retaking Shot ${retakeShotNumber}<br>Ready to Snap`;
        }
        document.getElementById('upload-btn').disabled = true;
        document.getElementById('upload-btn').textContent = 'DISABLED';
        
        // Disable other controls
        customShotsToggle.disabled = true;
        customFrameToggle.disabled = true;
        
        console.log(`RETAKE MODE: Preparing to capture and replace index ${retakeIndex}`);
    }


    // -------------------------------------------
    // UI Interaction: Apply Visual Effects
    // -------------------------------------------
    const allFilterClasses = [
        'filter-none', 'filter-bw', 'filter-warm',
        'filter-cool', 'filter-retro', 'filter-noir'
    ];
    const effectButtons = document.querySelectorAll('.effect-button');

    effectButtons.forEach(button => {
        button.addEventListener('click', () => {
            effectButtons.forEach(btn => btn.classList.remove('active'));
            button.classList.add('active');

            const newFilter = button.dataset.filter;
            if (cameraPreview) {
                cameraPreview.classList.remove(...allFilterClasses);
                cameraPreview.classList.add(newFilter);
            }
        });
    });

    // -------------------------------------------
    // Core Logic: Capture Functions
    // -------------------------------------------

    // Function to capture photo from video (FIXED FOR MIRRORING)
    function capturePhoto() {
        const canvas = document.createElement('canvas');
        const ctx = canvas.getContext('2d');
        canvas.width = cameraPreview.videoWidth;
        canvas.height = cameraPreview.videoHeight;
        
        if (canvas.width === 0 || canvas.height === 0) {
            throw new Error("Video stream dimensions are zero. Cannot capture.");
        }
        
        // CRITICAL FIX: Check if the preview was flipped (i.e., mirrored for the user)
        const isMirrored = cameraPreview.classList.contains('preview-flipped');
        
        ctx.save(); // Save the current canvas state

        if (isMirrored) {
            // Apply horizontal flip transformation for the capture
            // We translate to the right edge and scale by -1
            ctx.translate(canvas.width, 0);
            ctx.scale(-1, 1);
        }
        
        // Draw the current video frame onto the canvas
        ctx.drawImage(cameraPreview, 0, 0, canvas.width, canvas.height);
        
        ctx.restore(); // Restore the canvas state (clears the flip)

        // Using JPEG with 80% quality to reduce file size and improve stability for multi-shot
        return canvas.toDataURL('image/jpeg', 0.8); 
    }

    // Function to show countdown overlay and delay
    function showCountdown(seconds) {
        return new Promise(resolve => {
            if (seconds <= 0) {
                resolve();
                return;
            }

            const overlay = document.createElement('div');
            overlay.id = 'countdown-overlay';
            overlay.style.position = 'absolute';
            overlay.style.top = '50%';
            overlay.style.left = '50%';
            overlay.style.transform = 'translate(-50%, -50%)';
            overlay.style.fontSize = '5rem';
            overlay.style.fontWeight = 'bold';
            overlay.style.color = 'white';
            overlay.style.textShadow = '2px 2px 4px rgba(0,0,0,0.8)';
            overlay.style.zIndex = '10';
            overlay.style.pointerEvents = 'none';
            
            // Find the container of the video preview
            const previewContainer = cameraPreview.closest('.card.transparent-card');
            previewContainer.style.position = 'relative'; 
            previewContainer.appendChild(overlay);

            let count = seconds;
            overlay.textContent = count;

            const interval = setInterval(() => {
                count--;
                if (count > 0) {
                    overlay.textContent = count;
                } else {
                    clearInterval(interval);
                    overlay.remove();
                    resolve();
                }
            }, 1000);
        });
    }

    // --- MAIN CAPTURE SEQUENCE LOGIC (HANDLES BOTH INITIAL AND RETAKE) ---
    async function startCaptureSequence(frameSize, numShots, timerDuration) {
        
        // Determine the number of shots to take based on mode
        const shotsToTake = (retakeIndex !== null) ? 1 : numShots;
        
        const capturedImages = (retakeIndex !== null) ? existingImages : [];
        let completedSuccessfully = true;

        startButton.disabled = true;
        uploadButton.disabled = true;

        try {
            for (let i = 0; i < shotsToTake; i++) {
                try {
                    // Retake mode only runs once (i=0) and replaces the selected index
                    const currentShotNumber = (retakeIndex !== null) ? (parseInt(retakeIndex) + 1) : (i + 1);
                    const totalShots = (retakeIndex !== null) ? existingImages.length : numShots;
                    
                    startButton.textContent = `Shot ${currentShotNumber}/${totalShots} - Counting Down...`;
                    
                    await showCountdown(timerDuration); 

                    // Ensure video is ready
                    if (cameraPreview.readyState < 2) {
                        await new Promise(resolve => {
                            const checkReady = () => {
                                if (cameraPreview.readyState >= 2) {
                                    resolve();
                                } else {
                                    setTimeout(checkReady, 100);
                                }
                            };
                            checkReady();
                        });
                    }

                    // Capture the photo
                    const imageDataUrl = capturePhoto();
                    
                    if (retakeIndex !== null) {
                        // RETAKE MODE: Replace the specific index
                        const index = parseInt(retakeIndex);
                        capturedImages[index] = imageDataUrl;
                    } else {
                        // INITIAL MODE: Push to the end of the array
                        capturedImages.push(imageDataUrl);
                    }
                    
                    startButton.textContent = `Shot ${currentShotNumber}/${totalShots} Captured!`;
                    
                    // CRITICAL STABILITY FIX: Add a brief pause after capture
                    await new Promise(r => setTimeout(r, 100)); 

                    // Wait 500ms before starting the next shot countdown (if there is one in initial mode)
                    if (retakeIndex === null && i < numShots - 1) {
                         await new Promise(r => setTimeout(r, 500)); 
                    }

                } catch (shotError) {
                    console.error(`Error capturing Shot ${i + 1}:`, shotError);
                    alert(`Failed to capture Shot ${i + 1}. Stopping sequence. Please check camera stream/permissions.`);
                    completedSuccessfully = false;
                    break; 
                }
            }
        } catch (sequenceError) {
            console.error('Error during capture sequence setup:', sequenceError);
            completedSuccessfully = false;
        } finally {
            startButton.disabled = false;
            uploadButton.disabled = false;
            startButton.textContent = 'START';
        }

        if (completedSuccessfully && capturedImages.length > 0) {
            // Save settings (use the total number of shots, even in retake mode)
            localStorage.clear();
            localStorage.setItem('frameSize', frameSize.replace(/ /g, ''));
            localStorage.setItem('numShots', capturedImages.length); 
            localStorage.setItem('captureMode', 'camera');
            const activeButton = document.querySelector('.effect-button.active');
            const activeFilter = activeButton ? activeButton.dataset.filter : 'filter-none';
            localStorage.setItem('activeFilter', activeFilter);
            
            sessionStorage.clear();
            sessionStorage.setItem('capturedImagesArray', JSON.stringify(capturedImages));
            
            console.log(`Successfully completed capture sequence. Redirecting.`);
            
            // Perform the redirect to the review page
            window.location.href = 'reviewshots.html';
            
        } else if (completedSuccessfully && capturedImages.length === 0) {
             alert('Sequence finished, but no photos were captured. Please check camera permissions and try again.');
        }
    }


    // Handle 'Start' Button: Start multi-shot/retake capture sequence
    if (startButton) {
        startButton.addEventListener('click', () => {
            const frameSize = selectedFrameSize;
            const numShots = selectedNumShots; 
            const timerDuration = selectedTimerValue; 

            // Validate required fields only if NOT in retake mode
            if (retakeIndex === null) {
                if (frameSize === "" || numShots === 0) {
                    alert('Please select a "Frame Size" and "Shots" before starting.');
                    return;
                }
            } else {
                 // Retake mode validation: ensure we have an array to retake into
                if (existingImages.length === 0) {
                    alert('Cannot retake: Original shots array is missing.');
                    return;
                }
            }

            // Check if camera is available
            if (!cameraPreview.srcObject) {
                alert('Camera not available. Please allow camera access and ensure the camera stream is running.');
                return;
            }

            // Start the capture sequence
            startCaptureSequence(frameSize, numShots, timerDuration);
        });
    }

    // Handle 'Upload' Button: Trigger the hidden file input
    if (uploadButton && fileInput) {
        uploadButton.addEventListener('click', () => {
            const frameSize = selectedFrameSize;
            const numShots = selectedNumShots;
            
            if (frameSize === "" || numShots === 0) {
                alert('Please select a "Frame Size" and "Shots" before uploading.');
                return;
            }

            // 1. Set 'multiple' attribute based on the number of shots selected
            const numShotsInt = parseInt(numShots);
            if (numShotsInt > 1) {
                fileInput.setAttribute('multiple', 'multiple');
            } else {
                fileInput.removeAttribute('multiple');
            }
            
            fileInput.click();
        });
    }

    // Handle File Selection: Process uploaded image
    if (fileInput) {
        fileInput.addEventListener('change', async (event) => {
            const files = event.target.files;
            const numShots = selectedNumShots; 
            const frameSize = selectedFrameSize;
            
            if (files.length === 0) {
                // No files selected, exit
                return;
            }

            // Input Validation: Check if number of files matches numShots
            if (files.length !== numShots) {
                alert(`You selected ${files.length} files. Please select exactly ${numShots} shots.`);
                // Reset file input to allow re-selection
                event.target.value = null; 
                return;
            }

            const capturedImages = [];
            
            try {
                // Use Promise.all to handle reading all files asynchronously
                const filePromises = Array.from(files).map(file => {
                    if (!file.type.startsWith('image/')) {
                        throw new Error(`File '${file.name}' is not an image.`);
                    }
                    return new Promise((resolve, reject) => {
                        const reader = new FileReader();
                        reader.onload = (e) => resolve(e.target.result);
                        reader.onerror = reject;
                        reader.readAsDataURL(file);
                    });
                });
                
                const imageDataUrls = await Promise.all(filePromises);
                capturedImages.push(...imageDataUrls);

                // Save all settings and images to storage
                localStorage.clear();
                localStorage.setItem('frameSize', frameSize.replace(/ /g, ''));
                localStorage.setItem('numShots', numShots);
                localStorage.setItem('captureMode', 'upload');
                
                // Save the active filter for customizationphoto.html
                const activeButton = document.querySelector('.effect-button.active');
                const activeFilter = activeButton ? activeButton.dataset.filter : 'filter-none';
                localStorage.setItem('activeFilter', activeFilter); 

                sessionStorage.clear();
                sessionStorage.setItem('capturedImagesArray', JSON.stringify(capturedImages)); 
                
                console.log('Settings saved for upload. Redirecting.');
                
                window.location.href = 'reviewshots.html';
                
            } catch (error) {
                console.error('Error processing uploaded images:', error);
                alert(`Could not process files: ${error.message}. Please try again.`);
                event.target.value = null; 
            }
        });
    }

// -------------------------------------------
// Camera Activation and Management
// -------------------------------------------
    let currentStream = null;
    let currentDeviceId = null;
    let availableCameras = [];

    async function startCamera(deviceId = null) {
        try {
            if (currentStream) {
                currentStream.getTracks().forEach(track => track.stop());
            }

            const constraints = {
                video: {
                    deviceId: deviceId ? { exact: deviceId } : undefined,
                    width: { ideal: 1280 },
                    height: { ideal: 720 }
                }
            };

            currentStream = await navigator.mediaDevices.getUserMedia(constraints);
            cameraPreview.srcObject = currentStream;

            const videoTrack = currentStream.getVideoTracks()[0];
            currentDeviceId = videoTrack.getSettings().deviceId;
        } catch (error) {
            console.error('Error accessing camera:', error);
        }
    }

    async function enumerateCameras() {
        try {
            const devices = await navigator.mediaDevices.enumerateDevices();
            availableCameras = devices.filter(device => device.kind === 'videoinput');
        } catch (error) {
            console.error('Error enumerating devices:', error);
        }
    }

    async function initCamera() {
        await enumerateCameras();
        if (availableCameras.length > 0) {
            await startCamera(availableCameras[0].deviceId);
        }
    }

    if (navigator.mediaDevices && navigator.mediaDevices.getUserMedia) {
        initCamera();
    } 

    const switchCameraButton = document.getElementById('switch-camera-btn');
    
    // Switch Mirror Logic
    if (switchCameraButton) {
        switchCameraButton.addEventListener('click', () => {
            cameraPreview.classList.toggle('preview-flipped');
        });
    }
});
</script>

</body>
</html>